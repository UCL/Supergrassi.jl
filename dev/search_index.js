var documenterSearchIndex = {"docs":
[{"location":"#Supergrassi.jl","page":"Introduction","title":"Supergrassi.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the reference documentation of Supergrassi.jl.","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Types","page":"Introduction","title":"Types","text":"","category":"section"},{"location":"#Supergrassi.AssetsLiabilities","page":"Introduction","title":"Supergrassi.AssetsLiabilities","text":"struct AssetsLiabilities\n\nIn the matlab code these are called assets0 and assets1\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.CleanData","page":"Introduction","title":"Supergrassi.CleanData","text":"struct CleanData\n\nTop level structure for cleaned up input data.\n\nContains\n\nHouseholdData\nIndustryData\nConstants\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.Constants","page":"Introduction","title":"Supergrassi.Constants","text":"struct Constants\n\nStores constants read from settings file.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.Data","page":"Introduction","title":"Supergrassi.Data","text":"struct Data\n\nStores all the data required for the model, including household, industry, input-output data, and other relevant information.\n\nContains:\n\nhousehold: An instance of RawHouseHoldData containing household income and hours worked data.\nindustry: An instance of RawIndustryData containing industry capital, turnover, and inventory data.\ninput_output: An instance of InputOutput containing input-output data and matrices.\nimports: An instance of InputOutput containing import data and matrices.\ndepreciation: A DataFrame containing depreciation data.\nrisk_free_rate: A DataFrame containing risk-free rate data.\nassets: A DataFrame containing asset data.\nmodel_results: A DataFrame containing model results.\nmerge_codes_105: A DataFrame containing merge codes for 105 industries.\nmerge_codes_64: A DataFrame containing merge codes for 64 industries.\nothers: A DataFrame containing other relevant data such as taxes and subsidies.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.Elasticities","page":"Introduction","title":"Supergrassi.Elasticities","text":"struct Elasticities\n\nStores sets of elasticity constants.\n\nNames for reference in paper/matlab code:\n\nconsumption: α\nexport_eu: β1\nexport_world: β2\ninvestment: ρ\nproduction: ξ\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.Elasticity","page":"Introduction","title":"Supergrassi.Elasticity","text":"struct Elasticity\n\nStores components of an elasticity constant.\n\nNames for reference in paper/matlab code for e.g. production elasticity ξ:\n\nsubstitution::Float64: ξ\narmington::Float64: ξ_a\nsubstitution_uk_other::Float64: ~ξ\nskill_substitution::Float64: ξ_h\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.ExchangeRates","page":"Introduction","title":"Supergrassi.ExchangeRates","text":"struct ExchangeRates\n\nStores exchange rates from GBP to other currencies\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.FilePath","page":"Introduction","title":"Supergrassi.FilePath","text":"FilePath(path::String)\n\nA structure for file paths.\n\nFields\n\npath::String: The full path.\ndirectory::String: The directory.\nfile::String: The file name.\nextension::String: The file extension.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.ForeignRegionalValues","page":"Introduction","title":"Supergrassi.ForeignRegionalValues","text":"struct ForeignRegionalValues\n\nStores eu and rest of world components of a scalar quantity.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.HouseholdData","page":"Introduction","title":"Supergrassi.HouseholdData","text":"struct HouseholdData\n\nStores data on households\n\nNames reference for matlab code/paper\n\nincome::DataFrame: data.income_{lo, hi}\npayments::DataFrame: data.{hValueLO, hValueHI, hValue}\nhours::DataFrame: data.h{LO, HI}\nwages::DataFrame: data.w{LO, HI}\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.IndustryData","page":"Introduction","title":"Supergrassi.IndustryData","text":"struct IndustryData\n\nStores data on industries\n\nNames reference for matlab code/paper\n\ndepreciation::DataFrame: data.depreciation\ntax::DataFrame: data.taxValue{1,2}\ncapital::DataFrame: data.k{0,1}\nsurplus::DataFrame: data.kValue\nshock_stdev::DataFrame: data.sigmaBar\nassets_liabilities::AssetsLiabilities: AssetsLiabilities\nregional::RegionalData: RegionalData\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.InputMatrices","page":"Introduction","title":"Supergrassi.InputMatrices","text":"struct InputMatrices\n\nStores intermediate input production matrices .\n\nIn the matlab code these matrices are called mValue_*\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.InputOutput","page":"Introduction","title":"Supergrassi.InputOutput","text":"struct InputOutput\n\nStores input-output data matrix and other related information.\n\nContains:\n\nraw_data: The raw input-output data as a DataFrame.\ninput_output_matrix: The input-output matrix as a DataFrame.\nindustry_names: An array of industry names.\nfinal_consumption: An array of final consumption values.\ngross_fixed_capital_formation: An array of gross fixed capital formation values.\ndelta_v_value_uk: An array of delta V values for the UK.\nexports_eu_to_uk: An array of exports from the EU to the UK.\nexport_world_to_uk: An array of exports from the world to the UK.\ntotal_use: An array of total use values.\nservices_export: An array of services export values.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.ParameterSubset","page":"Introduction","title":"Supergrassi.ParameterSubset","text":"struct ParameterSubset\n\nStores a subset of parameters for gradient computation.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.Parameters","page":"Introduction","title":"Supergrassi.Parameters","text":"struct Parameters\n\nMain structure for parameters\n\nContains\n\nconstants::Constants : constant values\nconsumption::ParamsStruct : α\nexport_eu::ParamsStruct : β1\nexport_world::ParamsStruct : β2\nproduction::ParamsProduction : γ\ninvestment::ParamsStruct : ρ\n\nNote: The constructor checks that all reasonable parameters are non-negative unless log or derivatives is set to true.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.ParamsProduction","page":"Introduction","title":"Supergrassi.ParamsProduction","text":"struct ParamsProduction\n\nStores firms intermediate production parameters\n\nThese require a different structure from ParamsStruct because firms trade with all other firms and the parameter is a matrix that contains a value for each combination of firms.\n\nNames reference\n\nhuman::Vector{Float64} : γ_h\ncapital::Vector{Float64} :  γ_k\nlow_skill::Vector{Float64} : γ_L\nhigh_skill::Vector{Float64} : γ_H\nshock_mean::Vector{Float64} : μ\nshock_stdev::Vector{Float64} : ̄σ\nuk::Matrix{Float64} : γ_Md\neu::Matrix{Float64} : γ_Meu\nworld::Matrix{Float64} : γ_Mw\nagg::Matrix{Float64} : γ_M\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.ParamsStruct","page":"Introduction","title":"Supergrassi.ParamsStruct","text":"struct ParamsStruct\n\nStores parameters that are split between uk/eu/rest of the world.\n\nContains an optional field \"tilde\" which, for the export parameters β, is the share of foreign expenditure on UK exports.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.RawHouseHoldData","page":"Introduction","title":"Supergrassi.RawHouseHoldData","text":"struct RawHouseHoldData\n\nStores household data (income and hours worked).\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.RawIncomeData","page":"Introduction","title":"Supergrassi.RawIncomeData","text":"struct RawIncomeData\n\nStores high and low income data as DataFrames.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.RawIndustryData","page":"Introduction","title":"Supergrassi.RawIndustryData","text":"struct RawIndustryData\n\nStores raw industry data (capital, turnover, and inventory) as DataFrames.\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.RegionalData","page":"Introduction","title":"Supergrassi.RegionalData","text":"struct RegionalData\n\nStores industries data that is split between uk/eu/rest of the world.\n\nThe data is vectors with one value per industry stored in a DataFrame. Names for reference with the matlab code/paper:\n\ntotal_use::DataFrame: data.yValue / y\nconsumption::DataFrame:data.fValue / f\ndelta_v::DataFrame: data.deltaVValue / Δv\nexport_eu::DataFrame: data.x1Value / x1\nexport_world::DataFrame: data.x2Value / x2\ninvestment::DataFrame: data.IValue / I\ninput_matrices::InputMatrices: data.mValue / m InputMatrices\ntotals::Totals: data.{E, ISum, EX1, EX2} Totals\n\n\n\n\n\n","category":"type"},{"location":"#Supergrassi.Totals","page":"Introduction","title":"Supergrassi.Totals","text":"struct Totals\n\nStores sums of quantities over industries before renormalisation.\n\nNames for reference with the paper/matlab code:\n\nexpenditure::Float64: E\ninvestments::Float64: ISum\nimports::ForeignRegionalValues: EX1, EX2 ForeignRegionalValues\n\n\n\n\n\n","category":"type"},{"location":"#Functions","page":"Introduction","title":"Functions","text":"","category":"section"},{"location":"#Supergrassi.B-NTuple{7, Any}","page":"Introduction","title":"Supergrassi.B","text":"As far as I can tell, in the Matlab code chi0 is always 0, q0 is always 1. Therefore this method assumes chi0 = 0, q0 = 1 and simplifies the calculation.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.B-NTuple{9, Any}","page":"Introduction","title":"Supergrassi.B","text":"Second part of C.47\n\nB(iNZ) = 1 - parms.delta(iNZ) + pd(iNZ).(1-parms.tau(iNZ)).parms.chi0(iNZ)/parms.q0 ...       - rk(iNZ).*ROCTheta(iNZ)./(1-ROCTheta(iNZ));\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.Delta-Union{Tuple{T}, NTuple{8, T}} where T<:Real","page":"Introduction","title":"Supergrassi.Delta","text":"Function Delta as a function of logOmega, B and b as written in the paper (C. 47).\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.Delta_wrapper-NTuple{12, Any}","page":"Introduction","title":"Supergrassi.Delta_wrapper","text":"Wrapper around Delta that exposes logOmega, price_uk and zOC as the arguments for computation of derivatives H.3 - H.5 (on the RHS of H.1 and H.2)\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.G-Union{Tuple{T}, NTuple{13, T}} where T<:Real","page":"Introduction","title":"Supergrassi.G","text":"C. 44\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.TzOC-Tuple{Any}","page":"Introduction","title":"Supergrassi.TzOC","text":"Above C.1\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.add_aggregate!-Tuple{DataFrames.DataFrame}","page":"Introduction","title":"Supergrassi.add_aggregate!","text":"function add_aggregate!(df::DataFrame)\n\nAdd an aggregate column to a DataFrame that sums the UK, EU, and World columns.\n\nArguments\n\ndf::DataFrame: The DataFrame to which the aggregate column will be added.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.b-NTuple{6, Any}","page":"Introduction","title":"Supergrassi.b","text":"This method assumes q0 = 1 and simplifies the calculation\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.b-NTuple{7, Any}","page":"Introduction","title":"Supergrassi.b","text":"Second part of C.47\n\nb(iNZ) = rk(iNZ)./(parms.mu(iNZ).*(1-ROCTheta(iNZ)));\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.capital_fun-Union{Tuple{T}, NTuple{5, T}} where T<:Real","page":"Introduction","title":"Supergrassi.capital_fun","text":"capital_fun(surplus::T, tau::T, output::T, capital::T, elasticity::T) where {T <: Real}\n\nArgument:\n\nsurplus: Surplus value.\ntau: Tax parameter.\noutput: total household use, data.yValue.\ncapital: firms capital.\nelasticity: substitution elasticity parameter.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.capital_market-Tuple{}","page":"Introduction","title":"Supergrassi.capital_market","text":"function capital_market()\n\nDummy function for capital market. Returns a number.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.check_file_availability-Tuple{Dict}","page":"Introduction","title":"Supergrassi.check_file_availability","text":"check_file_availability(settings::Dict)\n\nVerifies the availability of data files.\n\nArguments\n\nsettings::Dict{<:Any, <:Any}: The settings dictionary.\n\nReturns\n\nDict{String, FilePath}: A dictionary of file paths.\n\nExamples\n\nsettings = Dict(\n    \"files\" => Dict(\n        \"input_dir\" => \"data\",\n        \"input_derived_dir\" => \"derived\",\n        \"inputs\" => Dict(\n            \"base\" => Dict(\n                \"data\" => \"data.csv\"\n            ),\n            \"derived\" => Dict(\n                \"scenario_independent\" => Dict(\n                    \"data\" => \"data.csv\"\n                ),\n                \"scenario_dependent\" => Dict(\n                    \"data\" => \"data.csv\"\n                )\n            )\n        )\n    ),\n    \"version\" => \"v1\",\n    \"files\" => Dict(\n        \"scenario\" => \"1\"\n    )\n)\n\nfilepaths = check_file_availability(settings)\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.classify_dict-Tuple{Dict{Any, Any}}","page":"Introduction","title":"Supergrassi.classify_dict","text":"classify_dict(dict::Dict)\n\nClassifies a dictionary type based on the types of its keys and values. Used to create a typed dictionary from an untyped dictionary extracted from a YAML file.\n\nArguments\n\ndict::Dict{Any, Any}: The dictionary to classify.\n\nReturns\n\nDict{key_type, value_type}: The classified dictionary.\n\nExamples\n\nuntyped_dict = YAML.load_file(\"settings.yaml\")\ntyped_dict = classify_dict(dict)\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.clean_1d_values-Tuple{Vector{<:Number}, Vector{<:Number}, Dict{String, String}, Dict{String, String}, Vector, Vector, Float64, Bool}","page":"Introduction","title":"Supergrassi.clean_1d_values","text":"function clean_1d_values(val::Vector{<:Number}, val_imp::Vector{<:Number}, map_64::Dict{String, String}, map_16::Dict{String, String}, names_105::Vector, names_16::Vector, split_factor::Float64, industries_in_cols::Bool)\n\nFunction to process the values that are split between uk, eu, world and stored in vectors.\n\nArguments\n\nval::Vector{<:Number}: The vector containing the values for UK.\nval_imp::Vector{<:Number}: The vector containing the values for imports.\nmap_64::Dict{String, String}: A dictionary mapping SIC 64 industry names to SIC 16 industry names.\nmap_16::Dict{String, String}: A dictionary mapping SIC 16 industry names to their final names.\nnames_105::Vector: A vector of industry names for SIC 105.\nnames_16::Vector: A vector of industry names for SIC 16.\nsplit_factor::Float64: The factor by which to split the imports between EU and World.\nindustries_in_cols::Bool: If true, industries will be on columns; otherwise, they will be on rows.\n\nReturns\n\nDataFrame: A DataFrame containing the cleaned values for UK, EU, World, and aggregate values.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.clean_2d_values-Tuple{Supergrassi.Data, Float64}","page":"Introduction","title":"Supergrassi.clean_2d_values","text":"function clean_2d_values(data::Data, split_factor::Float64)\n\nFunction to process the 2D values that are split between uk, eu, world and stored in matrices.\n\nArguments\n\ndata::Data: The Data struct containing input-output matrices and imports.\nsplit_factor::Float64: The factor by which to split the imports between EU and World.\n\nReturns\n\nInputMatrices: A struct containing the cleaned input-output matrices for UK, EU, World, and aggregate values.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.clean_assets_liabilities","page":"Introduction","title":"Supergrassi.clean_assets_liabilities","text":"funvtion clean_assets_liabilities(assets::DataFrame, year::Int64, map_to_16::Dict{String, String}, n_samples::Int64 = nrow(assets))\n\nWrapper function to clean assets and liabilities data.\n\nArguments\n\nassets::DataFrame: The DataFrame containing assets and liabilities data.\nyear::Int64: The year for which the data is to be cleaned.\nmap_to_16::Dict{String, String}: A dictionary mapping SIC 64 industry names to SIC 16 industry names.\nn_samples::Int64: The number of samples to limit per SIC 64 industry (default is the number of rows in assets.).\n\nReturns\n\nDataFrame: A cleaned DataFrame containing assets, liabilities, and their ratio, limited to n_samples per SIC 64 industry.\n\n\n\n\n\n","category":"function"},{"location":"#Supergrassi.clean_data-Tuple{Supergrassi.Data, Dict{String, Any}}","page":"Introduction","title":"Supergrassi.clean_data","text":"clean_data(data::Data, settings::Dict{String, Any})\n\nMain function for data cleaning. Should take in a Data struct and return a CleanData struct.\n\nArguments\n\ndata::Data: The Data struct containing various economic data.\nsettings::Dict{String, Any}: A dictionary containing constants and settings for the model.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.clean_exports-Tuple{Supergrassi.InputOutput, Supergrassi.InputOutput, Float64, Vector, Bool, Dict{String, String}, Dict{String, String}}","page":"Introduction","title":"Supergrassi.clean_exports","text":"function clean_exports(input_output::InputOutput, imports::InputOutput, split::Float64, names_16::Vector, industries_in_cols::Bool, map_64::Dict{String, String}, map_16::Dict{String, String})\n\nWrapper function to clean exports data.\n\nExports need a special treatment because they are a sum of export and services_export data frames. Service export is scaled by the sum of eu and world exports. Further refactoring definitely possible here.\n\nArguments\n\ninput_output::InputOutput: The InputOutput struct containing export data.\nimports::InputOutput: The InputOutput struct containing import data.\nsplit::Float64: The factor by which to split the imports between EU and World.\nnames_16::Vector: A vector of industry names for SIC 16.\nindustries_in_cols::Bool: If true, industries will be on columns; otherwise, they will be on rows.\nmap_64::Dict{String, String}: A dictionary mapping SIC 64 industry names to SIC 16 industry names.\nmap_16::Dict{String, String}: A dictionary mapping SIC 16 industry names to their final names.\n\nReturns\n\nDataFrame, DataFrame: Two DataFrames containing exports to the EU and World, respectively.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.clean_household-Tuple{Supergrassi.Data, Int64, Dict{String, String}, Dict{String, String}, Vector, Vector, Vector, Bool}","page":"Introduction","title":"Supergrassi.clean_household","text":"function clean_household(data::Data, year::Int64, map_64::Dict{String, String}, map_16::Dict{String, String}, names_105::Vector, names_64::Vector, names_16::Vector, industries_in_cols::Bool)\n\nFunction to process the household incomes and their derived data.\n\nArguments\n\ndata::Data: The Data struct containing household income and hours data.\nyear::Int64: The year for which the data is to be cleaned.\nmap_64::Dict{String, String}: A dictionary mapping SIC 105 industry names to SIC 64 industry names.\nmap_16::Dict{String, String}: A dictionary mapping SIC 64 industry names to SIC 16 industry names.\nnames_105::Vector: A vector of industry names for SIC 105.\nnames_64::Vector: A vector of industry names for SIC 64.\nnames_16::Vector: A vector of industry names for SIC 16.\nindustries_in_cols::Bool: If true, industries will be on columns; otherwise, they will be on rows.\n\nReturns\n\nHouseholdData: A struct containing cleaned household income, payments, hours, and wages data.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.clean_matrix-Tuple{DataFrames.DataFrame, Vector{String}, Dict{String, String}}","page":"Introduction","title":"Supergrassi.clean_matrix","text":"function clean_matrix(data::DataFrame, industry_names::Array{String, 1}, mapping::Dict{String, String})\n\nClean a matrix of data by reducing based on a mapping and renaming them with industry names.\n\nArguments\n\ndata::DataFrame: A DataFrame containing the matrix data to be cleaned.\nindustry_names::Array{String, 1}: An array of industry names to be used as column names.\nmapping::Dict{String, String}: A dictionary mapping old column names to new column names for reduction.\n\nReturns\n\nDataFrame: A new DataFrame with the matrix data, renamed columns, and reduced columns based on the mapping.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.clean_rows-Tuple{DataFrames.DataFrame, String, Vector{String}, Dict{String, String}}","page":"Introduction","title":"Supergrassi.clean_rows","text":"function clean_rows(data::DataFrame, row_names::String, col_names::Array{String, 1}, mapping::Dict{String, String})\n\nClean selected subset of rows in a DataFrame based on row names and rename columns.\n\nArguments\n\ndata::DataFrame: The DataFrame containing the data to be cleaned.\nrow_names::String: The name of the row to select.\ncol_names::Array{String, 1}: An array of new column names to rename the selected columns.\nmapping::Dict{String, String}: A dictionary mapping old column names to new column names for reduction.\n\nReturns\n\nDataFrame: A new DataFrame with selected rows, renamed columns, and reduced columns based on the mapping.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.clean_sigma_bar-Tuple{Vector, Vector{Int64}, Vector{String}}","page":"Introduction","title":"Supergrassi.clean_sigma_bar","text":"clean_sigma_bar(sigma_data::Vector, zero_list::Vector{Int64}, sic64::Vector{String})\n\nClean the sigma bar data by converting it to a DataFrame, parsing strings to Float64, and setting specified indices to zero.\n\nArguments\n\nsigma_data::Vector: A vector containing sigma bar data.\nzero_list::Vector{Int64}: A vector of indices where the sigma bar values should be set to zero.\nsic64::Vector{String}: A vector of SIC 64 industry names to be used as column names.\n\nReturns\n\nDataFrame: A DataFrame containing the cleaned sigma bar data, with specified indices set to zero.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.clean_vector-Tuple{Vector{<:Number}, Vector{String}, Dict{String, String}}","page":"Introduction","title":"Supergrassi.clean_vector","text":"function clean_vector(data::Vector{<:Number}, industry_names::Array{String, 1}, mapping::Dict{String, String})\n\nClean a vector of numbers by creating a DataFrame, renaming columns, and reducing columns based on a mapping.\n\nArguments\n\ndata::Vector{<:Number}: A vector of numbers to be cleaned.\nindustry_names::Array{String, 1}: An array of industry names to be used as column names.\nmapping::Dict{String, String}: A dictionary mapping old column names to new column names for reduction.\n\nReturns\n\nDataFrame: A new DataFrame with the vector data, renamed columns, and reduced columns based on the mapping.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.combine_dataframe_row_wise-Tuple{DataFrames.DataFrame, Function}","page":"Introduction","title":"Supergrassi.combine_dataframe_row_wise","text":"function combine_dataframe_row_wise(data::DataFrame, func::Function)\n\nCombine rows of a DataFrame by applying a function to each row.\n\nArguments\n\ndata::DataFrame: The DataFrame containing the data to be combined.\nfunc::Function: A function to apply to each row of the DataFrame.\n\nReturns\n\nDataFrame: A new DataFrame with the combined results, where each column is named after the original column names.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_advalorem_tax-Tuple{Supergrassi.IndustryData}","page":"Introduction","title":"Supergrassi.compute_advalorem_tax","text":"compute_advalorem_tax(data::IndustryData)\n\nCompute the ad valorem tax rate by combining product and production taxes, normalized by total use.\n\nArguments\n\ndata::IndustryData: Industry data containing tax and regional total use information\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_all_parameters-Union{Tuple{T}, Tuple{Supergrassi.CleanData, Vector{T}, Vector{T}, Vector{T}}, Tuple{Supergrassi.CleanData, Vector{T}, Vector{T}, Vector{T}, Bool}} where T<:Real","page":"Introduction","title":"Supergrassi.compute_all_parameters","text":"function compute_all_parameters(data::CleanData, price_uk::Vector{T}, price_eu::Vector{T}, price_world::Vector{T}, log_scale::Bool = false) where {T <: Real}\n\nCompute all utility function parameters and their derivativesfrom regional data, elasticities and prices.\n\nFor description of the parameters, see Table 2  of Nesheim et al (in prep). Return two Parameters structs, the first one contains values of parameters α, β1, β2, ρ and γ, the second one contains their derivatives with respect to price_uk.\n\nSee the tests in testparameterswith_data.jl for an example of use.\n\nArguments\n\ndata::CleanData: Data structure created by clean_data\nprice_uk::Vector{Real}: Logarithm of uk price index equilibrium variable\nprice_eu::Vector{Real}: Logarithm of eu price index\nprice_world::Vector{Real}: Logarithm of rest of world price index\nfun::Function=parameters_by_region: Function that computes three parameters by region. Either parameters_by_region or log_parameters_by_region\n\nSee also compute_parameter, compute_foreign_share, compute_production_parameter, Parameters\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_fixed_capital_consumption_constraint-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Supergrassi.IndustryData, Supergrassi.Parameters}} where T<:Real","page":"Introduction","title":"Supergrassi.compute_fixed_capital_consumption_constraint","text":"CEQ2 in Matlab code EstimationConstraint1.m L68\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_foreign_share-Union{Tuple{T}, Tuple{Supergrassi.ParamsStruct, DataFrames.DataFrame, Supergrassi.Elasticity, Vector{T}, Vector{T}, Vector{T}, Vararg{T, 4}}} where T<:Real","page":"Introduction","title":"Supergrassi.compute_foreign_share","text":"compute_foreign_share(param::ParamsStruct, dparam::ParamsStruct, demand::DataFrame,\n                      elasticity::Elasticity, price_uk::Vector{T}, price_eu::Vector{T}, price_world::Vector{T}, E::T, Ex::T,\n                      PTilde::T, exchange_rate::T) where {T<:Real}\n\nCompute the share of foreign expenditure on UK exports, β̃  in the paper by Nesheim et al.\n\nComputes the value and derivative of β̃  and adds them to the structures param and dparam, respectively. Because the strucs are immutable, a copy is created. Requires input outside of the regional demand data which is why this has been split into a different function from compute_parameter.\n\nArguments\n\nparam::ParamsStruct: Parameters.\ndparam::ParamsStruct: Derivatives of parameters.\ndemand::DataFrame: Demand data disaggregated by region.\nelasticity::Elasticity: Values for elasticity of substitution\nprice_uk::Vector{Real} : Logarithm of uk price index equilibrium variable.\nprice_eu::Vector{Real} : Logarithm of eu price index.\nprice_world::Vector{Real} : Logarithm of rest of world price index.\nE::Real: Household expenditure\nEx::Real: Foreign expenditure on UK exports\nPTilde::Real: The foreign price index.\nexchange_rate::Real: The exchange rate between domestic and foreign currency.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_imports_shares-Tuple{Supergrassi.Constants}","page":"Introduction","title":"Supergrassi.compute_imports_shares","text":"compute_imports_shares(constants::Constants)\n\nCompute the share of UK imports in total imports for EU and world regions.\n\nArguments\n\nconstants::Constants: Constants containing import and exchange rate information\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_input_by_skill-Tuple{Supergrassi.HouseholdData, Supergrassi.Elasticity}","page":"Introduction","title":"Supergrassi.compute_input_by_skill","text":"compute_input_by_skill(data::HouseholdData, elasticity::Elasticity)\n\nCompute input shares by skill level (low and high skill) based on household payments and wages.\n\nArguments\n\ndata::HouseholdData: Household data containing payments and wages information\nelasticity::Elasticity: Elasticity of substitution for production parameters\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_muI-Tuple{Supergrassi.IndustryData, Supergrassi.Elasticity}","page":"Introduction","title":"Supergrassi.compute_muI","text":"function compute_muI\n\nCompute μI parameter from industry data. Ref [L429 of B1SetupParameters.m](https://github.com/UCL/Supergrassi/blob/2f147384f02f8eef85e3cb59c73fd64ebfc19f82/code/matlab/macrov2/B1SetupParameters.m#L425)\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_normalisation_constraint-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Supergrassi.Parameters, Supergrassi.Elasticity}} where T<:Real","page":"Introduction","title":"Supergrassi.compute_normalisation_constraint","text":"F(n) in Matlab code ExcessDemand.m L344\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_objective_function-Tuple{Vector{<:Number}, Supergrassi.CleanData, Vector{<:Number}, Vector{<:Number}}","page":"Introduction","title":"Supergrassi.compute_objective_function","text":"compute_objective_function(x::Vector{<:Number}, data::CleanData, params::Parameters)\n\nComputes the objective function value based on a vector of parameters.\n\nArguments\n\nx::Vector{<:Number}: Vector containing log prices and zOC values.\ndata::CleanData: Cleaned data structure containing industry and regional information.\nparams::Parameters: Parameters structure containing production and constants.\n\nReturns\n\nobjective_value::Float64: The computed objective function value.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_objective_function-Tuple{Vector{<:Number}, Vector{<:Number}, Supergrassi.CleanData, Supergrassi.ParameterSubset}","page":"Introduction","title":"Supergrassi.compute_objective_function","text":"function compute_objective_function(log_price_uk::Vector{<:Number}, zOC::Vector{<:Number}, data::CleanData, params::Parameters)\n\nComputes the objective function value based on the log prices and zOC values.\n\nArguments\n\nlog_price_uk::Vector{<:Number}: Logarithm of UK prices.\nzOC::Vector{<:Number}: Vector of zOC values.\ndata::CleanData: Cleaned data structure containing industry and regional information.\nparams::Parameters: Parameters structure containing production and constants.\n\nReturns\n\nobjective_value::Float64: The computed objective function value.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_parameter-Union{Tuple{T}, Tuple{DataFrames.DataFrame, Supergrassi.Elasticity, Vector{T}, Vector{T}, Vector{T}, Bool}} where T<:Real","page":"Introduction","title":"Supergrassi.compute_parameter","text":"function compute_parameter(demand::DataFrame, elasticity::Elasticity, price_uk::Vector{T}, price_eu::Vector{T}, price_world::Vector{T}, fun::Function = parameters_by_region)\n\nCompute 1d utility function parameters and their derivatives from a regional demand DataFrame and the corresponding elasticity.\n\nArguments\n\ndemand::DataFrame: Demand data disaggregated by region\nelasticity::Elasticity: Values for elasticity of substitution\nprice_uk::Vector{Real} : Logarithm of uk price index equilibrium variable.\nprice_eu::Vector{Real} : Logarithm of eu price index.\nprice_world::Vector{Real}: Logarithm of rest of world price index.\nfun::Function = parameters_by_region: Function that computes three parameters by region. Either parameters_by_region or log_parameters_by_region\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_parameter_subset-Union{Tuple{T}, Tuple{Supergrassi.CleanData, Vector{T}, Vector{T}, Vector{T}}, Tuple{Supergrassi.CleanData, Vector{T}, Vector{T}, Vector{T}, Bool}} where T<:Real","page":"Introduction","title":"Supergrassi.compute_parameter_subset","text":"compute_parameter_subset(data::CleanData, price_uk::Vector{T}, price_eu::Vector{T}, price_world::Vector{T}, log_scale::Bool = false) where {T <: Real}\n\nCompute the parts of Parameters used for gradients.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_production_parameter-Union{Tuple{T}, Tuple{Supergrassi.CleanData, Vector{T}, Vector{T}, Vector{T}, Bool}} where T<:Real","page":"Introduction","title":"Supergrassi.compute_production_parameter","text":"function compute_production_parameter(data::CleanData, price_uk::Vector{T}, price_eu::Vector{T}, price_world::Vector{T}, fun::Function = parameters_by_region)\n\nCompute the 2d utility function parameters γM, γH, γK from regional InputMatrices and the corresponding elasticity.\n\nArguments\n\ndata::CleanData: Data structure created by clean_data\nprice_uk::Vector{Real} : Logarithm of uk price index equilibrium variable.\nprice_eu::Vector{Real} : Logarithm of eu price index.\nprice_world::Vector{Real}: Logarithm of rest of world price index.\nfun::Function=parameters_by_region: Function that computes three parameters by region. Either parameters_by_region or log_parameters_by_region\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.compute_wage_index-Tuple{Supergrassi.HouseholdData, Supergrassi.Elasticity}","page":"Introduction","title":"Supergrassi.compute_wage_index","text":"compute_wage_index(data::HouseholdData, elasticity::Elasticity)\n\nComputes aggregate wage index for households based on household data and elasticity of production.\n\nref\n\nArguments\n\ndata::HouseholdData: Data structure containing wages and payments DataFrames HouseholdData\nelasticity::Elasticity: Elasticity of substitution for production parameters (ξ)\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.constraint_function-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Supergrassi.CleanData, Supergrassi.Parameters, Vector{T}}} where T<:Number","page":"Introduction","title":"Supergrassi.constraint_function","text":"function constraint_function(x::Vector{T}, price_eu::Vector{T}, price_world::Vector{T},\n                         data::CleanData, params::Parameters, y::Vector{T}) where {T <: Real}\n\nArguments\n\nx::Vector{<:Number}: Vector containing equilibrium variables\nprice_eu::Vector{<:Number}: Vector containing the EU prices\nprice_world::Vector{<:Number}: Vector containing the rest of the world prices\ndata::CleanData: Cleaned data structure containing industry and regional information.\nparams::Parameters: Parameters structure containing production and constants.\ny::Vector{<:Number} : Vector constraints will be written to. Required due to Ipopt interface\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.constraint_jacobian-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Supergrassi.CleanData, Supergrassi.Parameters}} where T<:Number","page":"Introduction","title":"Supergrassi.constraint_jacobian","text":"function constraint_jacobian(x::Vector{<:Number}, data::CleanData, params::Parameters)\n\nArguments\n\nx::Vector{<:Number}: Vector containing equilibrium variables\nlog_price_eu::Vector{<:Number}: Vector containing the EU prices\nlog_price_world::Vector{<:Number}: Vector containing the rest of the world prices\ndata::CleanData: Cleaned data structure containing industry and regional information.\nparams::Parameters: Parameters structure containing production and constants.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.convert_to_ratio!-Tuple{DataFrames.DataFrame}","page":"Introduction","title":"Supergrassi.convert_to_ratio!","text":"convert_to_ratio!(df::DataFrame)\n\nConvert regional vector data into fractions of the aggregate value. Then renormalise the aggregate value by its sum. Nans are replaced with 0's.\n\nArguments\n\ndf::DataFrame: The DataFrame containing regional vector data to be converted into ratios.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.convert_to_ratio!-Tuple{Supergrassi.HouseholdData}","page":"Introduction","title":"Supergrassi.convert_to_ratio!","text":"convert_to_ratio!(data::HouseholdData)\n\nConvert household data into ratios of low and high payments to the sum of low and high payments.\n\nArguments\n\ndata::HouseholdData: The HouseholdData struct containing household data to be converted into ratios.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.convert_to_ratio!-Tuple{Supergrassi.InputMatrices}","page":"Introduction","title":"Supergrassi.convert_to_ratio!","text":"convert_to_ratio!(data::InputMatrices)\n\nConvert regional matrix data to fractions of the aggregate value Nans are replaced with 0's\n\nArguments\n\ndata::InputMatrices: The InputMatrices struct containing regional matrix data to be converted into ratios.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.convert_to_ratio!-Tuple{Supergrassi.RegionalData}","page":"Introduction","title":"Supergrassi.convert_to_ratio!","text":"convert_to_ratio!(data::RegionalData)\n\nConvert regional data into ratios of region / sum(regions)\n\nArguments\n\ndata::RegionalData: The RegionalData struct containing regional data to be converted into ratios.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.correct_exports_with_services!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}","page":"Introduction","title":"Supergrassi.correct_exports_with_services!","text":"function correct_exports_with_services!(export_to_eu::DataFrame, export_to_world::DataFrame, services_export::DataFrame)\n\nFunction to correct exports by accounting for NaN values and scaling appropriately.\n\nArguments\n\nexport_to_eu::DataFrame: DataFrame containing exports to the EU.\nexport_to_world::DataFrame: DataFrame containing exports to the World.\nservices_export::DataFrame: DataFrame containing service exports.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.create_filepath-Tuple{String}","page":"Introduction","title":"Supergrassi.create_filepath","text":"create_filepath(basepath::String)\n\nCreates a file path.\n\nArguments\n\nfile_path::FilePath: The file path object.\n\nReturns\n\nBool: Whether the file path is valid.\n\nExamples\n\nfile_path = FilePath(\"data.csv\")\nprintln(is_valid) # true\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.create_filepath_from_template-Tuple{String, Dict{String, Any}}","page":"Introduction","title":"Supergrassi.create_filepath_from_template","text":"create_filepath_from_template(basepath::String, substitution_dict::Dict{String, Any})\n\nCreates a file path from a template string and a dictionary of substitutions.\n\nArguments\n\nbasepath::String: The template string.\nsubstitution_dict::Dict{String, Any}: The dictionary of substitutions.\n\nReturns\n\nFilePath: The file path object.\n\nExamples\n\nsubstitutions = Dict(\n    \"name\" => \"data\",\n    \"format\" => \"csv\",\n    \"directory\" => \"dir\",\n    \"suffix\" => 1,\n)\n\ntemplate = \"{directory}/{name}{suffix}.{format}\"\nfilepath = create_filepath_from_template(template, substitutions)\nprintln(filepath.path) # \"dir/data1.csv\"\nprintln(filepath.directory) # \"dir\"\nprintln(filepath.file) # \"data1.csv\"\nprintln(filepath.extension) # \".csv\"\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.create_map_105_to_64","page":"Introduction","title":"Supergrassi.create_map_105_to_64","text":"function create_map_105_to_64(merge_codes::DataFrame, verbose::Bool = false)\n\nCreate a mapping from SIC 105 industry names to SIC 64 industry names.\n\nArguments\n\nmerge_codes::DataFrame: A DataFrame containing the mapping between SIC 105 and SIC 64 industry names. It should have two columns: sic105 containing SIC 105 industry names and sic64 containing SIC 64 industry names.\nverbose::Bool: If true, prints the initial and final industry names.\n\nReturns\n\nDict{String, String}: A dictionary mapping SIC 105 industry names to SIC 64 industry names.\n\n\n\n\n\n","category":"function"},{"location":"#Supergrassi.create_map_64_to_16","page":"Introduction","title":"Supergrassi.create_map_64_to_16","text":"function create_map_105_to_64(merge_codes::DataFrame, verbose::Bool = false)\n\nCreate a mapping from SIC 64 industry names to SIC 16 industry names.\n\nArguments\n\nmerge_codes::DataFrame: A DataFrame containing the mapping between SIC 64 and SIC 16 industry names. It should have two columns: x1 containing SIC 64 industry names and x7 containing SIC 16 industry names.\nverbose::Bool: If true, prints the initial and final industry names.\n\nReturns\n\nDict{String, String}: A dictionary mapping SIC 64 industry names to SIC 16 industry names.\n\n\n\n\n\n","category":"function"},{"location":"#Supergrassi.expenditure_by_region-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, Supergrassi.Elasticity}} where T<:Real","page":"Introduction","title":"Supergrassi.expenditure_by_region","text":"function expenditure_by_region(param::Vector{T}, price::Vector{T}, log_expenditure::Vector{T}, log_price_index::Vector{T}, elasticity::Elasticity) where {T <: Real}\n\nCompute expenditure for region. Called [EF, EX1, EX2, EI, EM] in Matlab code.\n\nArguments\n\nparam::Vector{T} : parameter for region. One of [α, β1, β2, ρ, γ]\nprice::Vector{T} : prices for region.\nlog_expenditure::Vector{T} : expenditure by commodity, see log_expenditure\nlog_price_index::Vector{T} : price index. See log_price_index\nelasticity::Elasticity : elasticity struct corresponding to parameter. Must contain armington. See Elasticity\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.export_spending-Union{Tuple{T}, Tuple{T, Vector{T}, Vararg{T, 4}}} where T<:Real","page":"Introduction","title":"Supergrassi.export_spending","text":"function export_spending(elasticity, tilde_param, logPXBar, exchange_rate, ETilde, PTilde)\n\nComputes foreign spending on UK exports (logEXTilde).\n\nArguments\n\nelasticity::Real : substitution elasticity\ntilde_param::Vector{Real} : share of foreign expenditure on UK exports, see ParamsStruct. Vector of size 1.\nlogPXBar::Real : log of aggregate price index, see log_agg_price_index\nexchange_rate::Real : exhange rate to foreign currency, see Constants\nEtilde::Real: EU expenditure on UK exports, see Constants\nPtilde::Real : UK export price index, see Constants\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.generate_constants-Tuple{Supergrassi.Data, Dict{String, Any}}","page":"Introduction","title":"Supergrassi.generate_constants","text":"generate_constants(data::Data, settings::Dict{String, Any})\n\nGenerate a Constants struct from the provided data and settings.\n\nArguments\n\ndata::Data: The Data struct containing various economic data.\nsettings::Dict{String, Any}: A dictionary containing constants and settings for the model.\n\nReturns\n\nConstants: A Constants struct containing the year, exchange rates, interest rate, total imports, import tariffs, export costs, and elasticities.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.group_columns_by_new_name-Tuple{Dict{String, String}}","page":"Introduction","title":"Supergrassi.group_columns_by_new_name","text":"function group_columns_by_new_name(mapping::Dict{String, String})\n\nGroup columns by their new names based on a mapping.\n\nArguments\n\nmapping::Dict{String, String}: A dictionary mapping old column names to new column names.\n\nReturns\n\nDict{String, Vector{Symbol}}: A dictionary where keys are new column names and values are vectors of old column names (as Symbols) that map to them.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.group_dataframes","page":"Introduction","title":"Supergrassi.group_dataframes","text":"function group_dataframes(dfs::AbstractArray, col_names::AbstractArray, industry_names::AbstractArray, industries_on_cols::Bool = true, reduction_fun::Function = nothing, mapping::Dict{String, String} = Dict(); kwargs...)\n\nGroup multiple DataFrames by industry names and aggregate their values.\n\nArguments\n\ndfs::AbstractArray: An array of DataFrames to be grouped.\ncol_names::AbstractArray: An array of column names for the resulting DataFrame.\nindustry_names::AbstractArray: An array of industry names to be used as row names.\nindustries_on_cols::Bool: If true, industries will be on columns; otherwise, they will be on rows.\nreduction_fun::Function: A function to apply for data aggregation (default is nothing).\nmapping::Dict{String, String}: A dictionary mapping old column names to new column names.\nkwargs...: Additional keyword arguments to be passed to the reduction_fun.\n\nReturns\n\nDataFrame: A DataFrame with industries as rows or columns, depending on industries_on_cols, and aggregated values.\n\n\n\n\n\n","category":"function"},{"location":"#Supergrassi.intermediate_goods_price_index-Union{Tuple{T}, NTuple{7, T}} where T<:Real","page":"Introduction","title":"Supergrassi.intermediate_goods_price_index","text":"intermediate_goods_price_index(log_price_uk::T, zOC::T, tau::T, mu::T, gammaK::T, K0::T, xi::T) where {T <: Real}\n\nComputes the intermediate goods price index for a single industry, Step 1 of ExcessDemand.m.\n\nArguments\n\nlog_price_uk::T: Logarithm of UK price\nzOC::T: Operating cost parameter\ntau::T: Ad Valorem tax rate\nmu::T: Productivity shock mean\ngammaK::T: Capital input parameter\nK0::T: Current year capital value\nxi::T: Production substitution elasticity\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.intermediate_goods_price_index-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, T}} where T<:Real","page":"Introduction","title":"Supergrassi.intermediate_goods_price_index","text":"intermediate_goods_price_index(log_price_uk::Vector{T}, zOC::Vector{T}, tau::Vector{T}, mu::Vector{T}, gammaK::Vector{T}, K0::Vector{T}, xi::T) where {T <: Real}\n\nComputes the intermediate goods price index for multiple industries, Step 1 of ExcessDemand.m.\n\nArguments\n\nlog_price_uk::Vector{T}: Logarithm of UK prices\nzOC::Vector{T}: Operating cost parameters\ntau::Vector{T}: Ad Valorem tax rates\nmu::Vector{T}: Productivity shock means\ngammaK::Vector{T}: Capital input parameters\nK0::Vector{T}: Current year capital values\nxi::T: Production substitution elasticity\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.labor_fun-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Introduction","title":"Supergrassi.labor_fun","text":"labor_fun(labor::T, log_wages::T, elasticity::T) where {T <: Real}\n\nArgument:\n\nlabor: Labor input.\nlog_wages: Log of wages.\nelasticity: Elasticity parameter.\n\nSee also\n\ncompute_wage_index\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.labor_supply-Tuple{Supergrassi.HouseholdData, Supergrassi.Constants, Supergrassi.Parameters}","page":"Introduction","title":"Supergrassi.labor_supply","text":"Compute parms.logH, in matlab code B1_SetupParameters.m L370\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.logTauPdMu-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Introduction","title":"Supergrassi.logTauPdMu","text":"Helper function to compute log of tau * mu * price_uk\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.logTauPdYBar-NTuple{7, Any}","page":"Introduction","title":"Supergrassi.logTauPdYBar","text":"Helper function to compute log of tau * mu * ybar\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_agg_price_index-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T<:Real","page":"Introduction","title":"Supergrassi.log_agg_price_index","text":"function log_agg_price_index(param_agg::Vector{T}, log_price_index::Vector{T}, elasticity::T) where {T<:Real}\n\nCompute the log of aggregate price index (logPBar)\n\nArguments\n\nparam_agg::Vector{Real} : aggregate parameter, one of [α, β1, β2, ρ, γ]\nlog_price_index::Vector{Real} : log of price index (by commodity, logP), see log_price_index\n`elasticity::Real : substitution elasticity\n\nOutput\n\nlogPBar::Real\n\nSee also\n\nParamsStruct, log_price_index\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_eu_expenditure_on_uk_exports-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vararg{T, 6}}} where T<:Real","page":"Introduction","title":"Supergrassi.log_eu_expenditure_on_uk_exports","text":"function log_eu_expenditure_on_uk_exports(log_price_index::Vector{T}, quantity::Vector{T},Ex::T, ETilde::T, ePx::T, PTilde::T, elasticity::T,elasticity_tilde::T) where {T <: Real}\n\nCompute the share of EU expenditure on UK exports, defined in section 2.2.1 of the main paper.\n\nfor the export parameters β, this is the share of foreign expenditure on UK exports.\n\nArguments\n\nlog_price_index::Vector{Real} : price index computed by log_price_index\nquantity::Vector{Real} : Quantity of domestically-produced good i exported to the EU\nEx::Real : sum of imports\nEtilde::Real: EU expenditure on UK exports\nePx::Real : exchange rate to foreign currency\nPtilde::Real : UK export price index\nelasticity::Real : substitution elasticity\nelasticity_tilde::Real : substitution from uk to other elasticity\n\nSee also ParamsStruct.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_expenditure-Union{Tuple{T}, Tuple{Vector{T}, T, T, Vector{T}, T}} where T<:Real","page":"Introduction","title":"Supergrassi.log_expenditure","text":"function log_expenditure(param_agg::Vector{T}, expenditure::T, elasticity::T, logPf::Vector{T}, logPBar::T) where {T <: Real}\n\nCompute aggregate expenditure by commodity. Called [LogEF, LogEX1, LogEX2, LogEI, LogEM] in Matlab code.\n\nArguments\n\nparam_agg::Vector{T} : aggregate parameter. One of [α, β1, β2, ρ, γ]\nelasticity::Elasticity : elasticity struct corresponding to parameter. Must contain armington. See Elasticity\nexpenditure::T : expenditure\nlog_price_index::Vector{T} : price index. See log_price_index\nlog_agg_price_index::Vector{T} : aggregate price index. See log_agg_price_index\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_parameter_by_region-Union{Tuple{T}, NTuple{4, T}} where T<:Real","page":"Introduction","title":"Supergrassi.log_parameter_by_region","text":"function log_parameter_by_region(elasticity::T, quantity_region::T, logP_region::T, logP::T) where {T <: Real}\n\nCompute log of an utility function parameter for a single region. See parameter_by_region\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_parameters_by_region-Union{Tuple{T}, NTuple{7, T}} where T<:Real","page":"Introduction","title":"Supergrassi.log_parameters_by_region","text":"function log_parameters_by_region(elasticity::T,log_price_uk::T,log_price_eu::T,log_price_world::T,quantity_uk::T,quantity_eu::T,quantity_world::T) where {T <: Real}\n\nCompute log of utility function parameters. See parameters_by_region.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_price_index-Union{Tuple{T}, NTuple{7, T}} where T<:Real","page":"Introduction","title":"Supergrassi.log_price_index","text":"function log_price_index(elasticity::T,log_price_uk::T, log_price_eu::T, log_price_world::T,demand_uk::T, demand_eu::T, demand_world::T) where {T <: Real}\n\nCompute the log of the consumer price index. See price_index\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_price_index-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, T}} where T<:Real","page":"Introduction","title":"Supergrassi.log_price_index","text":"function log_price_index(param::ParamsStruct, prices::DataFrame, elasticity::T, export_cost::T) where {T<:Real}\n\nCompute the log of final price index (logP) for export commodities, taking into account the export cost\n\nArguments\n\nparam::ParamsStruct : parameters by region, one of [α, β1, β2, ρ, γ], see ParamsStruct\nprices::DataFrame : prices for uk, eu, rest of world\n`elasticity::Real : armington elasticity\nexport_cost::Real : export cost parameter, see Constants\n\nSee also\n\nParamsStruct, Constants\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_price_index-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, T}} where T<:Real","page":"Introduction","title":"Supergrassi.log_price_index","text":"function log_price_index(param::ParamsStruct, prices::DataFrame, elasticity::T) where {T<:Real}\n\nCompute the log of final price index (logP) for each commodity\n\nArguments\n\nparam::ParamsStruct : parameters by region, one of [α, β1, β2, ρ, γ], see ParamsStruct\nprices::DataFrame : prices for uk, eu, rest of world\n`elasticity::Real : armington elasticity\n\nSee also\n\nParamsStruct\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_total_price_index-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{T}}} where T<:Real","page":"Introduction","title":"Supergrassi.log_total_price_index","text":"function log_total_price_index(elasticity::T, log_price_index::Vector{T}, quantity::Vector{T}) where {T <: Real}\n\nCompute the total consumer price index defined in equation 2.7 of the main paper as \bar{P}. Matlab code reference e.g. ComputeTheta.m line 58.\n\nArguments\n\nelasticity::Real : substitution elasticity\nlog_price_index::Vector{Real} : price index computed by log_price_index\nquantity:Vector{Real} : aggregate quantity [f, x1, x2, I, m]\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.log_weight_kernel-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Introduction","title":"Supergrassi.log_weight_kernel","text":"log_weight_kernel(a::T, b::T, elasticity::T) where {T <: Real}\n\ncomputes log(a/b^(1-elasticity))\n\nArgument:\n\na: Numerator value (in log form).\nb: Denominator base value (in log form).\nelasticity: substitution elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.market_clearing_price_constraint-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T, Vector{T}, Vector{T}, T, Supergrassi.Parameters, Supergrassi.IndustryData, Supergrassi.Constants}} where T<:Real","page":"Introduction","title":"Supergrassi.market_clearing_price_constraint","text":"function market_clearing_price(price_uk::Vector{T}, operating_cost::Vector{T}, household_expenditure::T,\n                               price_eu::Vector{T}, price_world::Vector{T},\n                               elasticities::Elasticities, params::Parameters, data::IndustryData) where {T <: Real}\n\nCalculate the market clearing price, equation 4.1.\n\nEquilibrium variables price_uk, operating_cost, household_expenditure are independent arguments. Note that the prices are NOT on log scale.\n\nArguments\n\nprice_uk::Vector{Real} : prices for uk (pd)\noperating_cost::Vector{Real} : (zOC)\nhousehold_expenditure::Real : (E)\nprice_eu::Vector{Real} : prices for eu (peu)\nprice_world::Vector{Real} : prices for rest of world (pw)\nelasticities::Elasticities\nparams::Parameters\ndata::IndustryData\n\nOutputs\n\nTerms of the price index F as a tuple of Vectors\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.market_clearing_price_constraint-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Supergrassi.Parameters, Supergrassi.IndustryData, Supergrassi.Constants}} where T<:Real","page":"Introduction","title":"Supergrassi.market_clearing_price_constraint","text":"function market_clearing_price(x::Vector{T}, log_price_eu::Vector{T}, log_price_world::Vector{T},\n                               params::Parameters, data::IndustryData, constants::Constants) where {T <: Real}\n\nCalculate the market clearing price constraint, equation 4.1.\n\nUses a single vector x of equilibrium variables as input. Returns a single vector F as output. Note that the prices are NOT on log scale.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.merge_quarterly_data-Tuple{DataFrames.DataFrame, Int64, Vector, Function}","page":"Introduction","title":"Supergrassi.merge_quarterly_data","text":"function merge_quarterly_data(df::DataFrame, year::Int64, industry_names::Vector, fun::Function)\n\nMerge quarterly data for a specific year by applying a function to each row.\n\nArguments\n\ndf::DataFrame: The DataFrame containing quarterly data.\nyear::Int64: The year for which the data is to be merged.\nindustry_names::Vector: A vector of industry names to be used as row names.\nfun::Function: A function to combine the quarterly data (e.g., sum).\n\nReturns\n\nDataFrame: A new DataFrame with the merged data for the specified year, with industry names as row names.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.parameter_by_region-Union{Tuple{T}, NTuple{4, T}} where T<:Real","page":"Introduction","title":"Supergrassi.parameter_by_region","text":"function parameter_by_region(elasticity::T, quantity_region::T, logP_region::T, logP::T) where {T <: Real}\n\nCompute an utility function parameter for a single region\n\nArguments\n\nelasticity::Real : substitution elasticity\nquantitity_region::Real : quantity for the region. One of [f, x1, x2, I, m]\nlogP_region::Real : log of price index for region\nlogP::Real :  log of aggregate price index\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.parameters_by_region-Union{Tuple{T}, NTuple{7, T}} where T<:Real","page":"Introduction","title":"Supergrassi.parameters_by_region","text":"function parameters_by_region(elasticity::T,log_price_uk::T,log_price_eu::T,log_price_world::T,quantity_uk::T,quantity_eu::T,quantity_world::T) where {T <: Real}\n\nCompute utility function parameters by region considered in the model (uk, eu, rest of world). Parameters of this type appear in multiple utility functions in the paper, and are annotated (at least) α, β1, β2, γ and ρ.\n\nThis is refactored from the Matlab code in e.g. ComputeTheta lines 62-64\n\nArguments\n\nelasticity::Real : substitution elasticity. One of [ϵ, χ1, χ2, η, ξ]\nlog_price_{uk, eu, w}::Real : log price indices for each region [log(p)]\nquantity_{uk, eu, w}::Real :  quantity for the region. One of [f, x1, x2, I, m]\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.parse_string_dataframe!","page":"Introduction","title":"Supergrassi.parse_string_dataframe!","text":"function parse_string_dataframe!(df::DataFrame, T::Type, default_val=nothing)\n\nParse string columns in a DataFrame to a specified type, replacing missing values with a default value.\n\nArguments\n\ndf::DataFrame: The DataFrame containing the string columns to be parsed.\nT::Type: The type to which the string columns should be parsed (e.g., Float64).\ndefault_val: The value to replace missing values with (default is nothing).\n\n\n\n\n\n","category":"function"},{"location":"#Supergrassi.postprocess_clean_data!-Tuple{Supergrassi.CleanData}","page":"Introduction","title":"Supergrassi.postprocess_clean_data!","text":"postprocess_clean_data!(data::CleanData)\n\nPost-process the cleaned data to convert regional data into ratios, round shares, and rescale the data.\n\nArguments\n\ndata::CleanData: The CleanData struct containing household and industry data to be post-processed.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.price_index-Union{Tuple{T}, NTuple{7, T}} where T<:Real","page":"Introduction","title":"Supergrassi.price_index","text":"function price_index(elasticity::T,log_price_uk::T, log_price_eu::T, log_price_world::T,demand_uk::T, demand_eu::T, demand_world::T) where {T <: Real}\n\nCompute the the consumer price index defined in equation 2.3 of the main paper as \bar{p}. Matlab code reference e.g. ComputeTheta.m line 49.\n\nArguments\n\nelasticity::Real : substitution elasticity\nlog_price_{uk, eu, w}::Real : log price indices for each region [log(p)]\ndemand_{uk, eu, w}::Real :  demand for the region. One of [f, x1, x2, I, m]\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.productivity_shock_mean-Union{Tuple{T}, Tuple{Supergrassi.Elasticity, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, T, T, T, T, T, Int64, Bool}} where T<:Real","page":"Introduction","title":"Supergrassi.productivity_shock_mean","text":"function productivity_shock_mean(elasticity::Elasticity, prices_uk::Vector{T}, prices_eu::Vector{T}, prices_world::Vector{T},\n                             input_uk::Vector{T}, input_eu::Vector{T}, input_world::Vector{T}, input_agg::Vector{T},\n                             surplus::T, capital::T, output::T, labor::T, log_wages::T, tau::T, row::Int, log_scale::Bool) where {T <: Real}\n\nCompute the productivity shock mean μ\n\nprices_uk::Vector{Real} : uk price index\nprices_eu::Vector{Real} : eu price index\nprices_world::Vector{Real} : rest of world price index\ninput_uk::Vector{Real} : uk firms intermediate input\ninput_eu::Vector{Real} : eu firms intermediate input\ninput_world::Vector{Real} : rest of world firms intermediate input\ninput_agg::Vector{Real} : aggreagete firms intermediate input\nsuprlus::Real : firms suprlus, data.kValue\ncapital::Real : firms capital, data.k0\noutput::Real : total household use, data.yValue\nlabor::Real : payments for labor, data.hValue\nlog_wages::Real : aggregate wages of households\nelasticity::Real : substitution elasticity\ntau::Real : ratio of taxes to household use\nrow::Int : index of firm i\nlog_scale::Bool : return parameters in log scale\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.read_csv-Tuple{String}","page":"Introduction","title":"Supergrassi.read_csv","text":"read_csv(file::String)\n\nReads a CSV file and returns a DataFrame.\n\nArguments\n\nfile::String: The path to the CSV file.\n\nReturns\n\nDataFrame: A DataFrame containing the data from the CSV file.\n\nExamples\n\ndf = read_csv(\"data.csv\")\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.read_excel-Tuple{String}","page":"Introduction","title":"Supergrassi.read_excel","text":"read_excel(file::String; sheet::String=\"Sheet1\", range::String=\"A1:Z1000\")\n\nReads an Excel file and returns a DataFrame.\n\nArguments\n\nfile::String: The path to the Excel file.\nsheet::String: The name of the sheet to read. Default is \"Sheet1\".\nrange::String: The range of cells to read, in Excel format (e.g., \"A1:Z1000\"). Default is \"A1:Z1000\".\n\nReturns\n\nDataFrame: A DataFrame containing the data from the specified sheet and range.\n\nExamples\n\ndf = read_excel(\"data.xlsx\", sheet=\"Sheet1\", range=\"A1:Z1000\")\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.read_settings-Tuple{Supergrassi.FilePath}","page":"Introduction","title":"Supergrassi.read_settings","text":"read_settings(file_path::FilePath)\n\nReads settings from a YAML file and classifies the dictionary.\n\nArguments\n\nfile_path::FilePath: The path to the YAML file containing settings.\n\nReturns\n\nDict{key_type, value_type}: The classified settings dictionary.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.reduce_columns_by_group_sum-Tuple{DataFrames.DataFrame, Dict{String, String}}","page":"Introduction","title":"Supergrassi.reduce_columns_by_group_sum","text":"function reduce_columns_by_group_sum(df::DataFrame, mapping::Dict{String, String})\n\nReduce columns in a DataFrame by summing them based on a mapping.\n\nArguments\n\ndf::DataFrame: The DataFrame containing the columns to be reduced.\nmapping::Dict{String, String}: A dictionary mapping old column names to new column names.\n\nReturns\n\nDataFrame: A new DataFrame with reduced columns, where each new column is the sum of the old columns that map to it.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.reduce_columns_by_group_weighted_mean-Tuple{DataFrames.DataFrame, Dict{String, String}}","page":"Introduction","title":"Supergrassi.reduce_columns_by_group_weighted_mean","text":"fubction reduce_columns_by_group_weighted_mean(df::DataFrame, mapping::Dict{String, String}; weights::DataFrame = DataFrame(ones(1,ncol(df)), names(df)))\n\nReduce columns in a DataFrame by calculating the weighted mean based on a mapping.\n\nArguments\n\ndf::DataFrame: The DataFrame containing the columns to be reduced.\nmapping::Dict{String, String}: A dictionary mapping old column names to new column names.\nweights::DataFrame: A DataFrame containing weights for each column. Defaults to a DataFrame of ones.\n\nReturns\n\nDataFrame: A new DataFrame with reduced columns, where each new column is the weighted mean of the old columns that map to it.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.rescale_data!-Tuple{Supergrassi.CleanData}","page":"Introduction","title":"Supergrassi.rescale_data!","text":"rescale_data!(data::CleanData)\n\nRe-scale the data that does not get convereted into a ratio explicitly, following https://github.com/UCL/Supergrassi/blob/main/code/matlab/macro_v2/DataCleaning/RescaleData.m.\n\nArguments\n\ndata::CleanData: The CleanData struct containing household and industry data to be rescaled.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.rk-NTuple{7, Any}","page":"Introduction","title":"Supergrassi.rk","text":"C. 48\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.round_shares!","page":"Introduction","title":"Supergrassi.round_shares!","text":"round_shares!(data::InputMatrices, threshold = 1e-4)\n\nRound shares in regional matrix data\n\nArguments\n\ndata::InputMatrices: The InputMatrices struct containing regional matrix data to be rounded.\n\n\n\n\n\n","category":"function"},{"location":"#Supergrassi.round_shares!-2","page":"Introduction","title":"Supergrassi.round_shares!","text":"round_shares!(data::RegionalData, threshold::Float64 = 1e-4)\n\nRound values below threshold in regional data to 0, then rescale so that regions sum to 1.\n\nArguments\n\ndata::RegionalData: The RegionalData struct containing regional data to be rounded.\n\n\n\n\n\n","category":"function"},{"location":"#Supergrassi.round_shares!-3","page":"Introduction","title":"Supergrassi.round_shares!","text":"round_shares!(df::DataFrame, threshold = 1e-4)\n\nRound shares in regional vector data\n\nArguments\n\ndf::DataFrame: The DataFrame containing regional data to be rounded.\nthreshold: The threshold below which values are set to 0 (default is 1e-4).\n\n\n\n\n\n","category":"function"},{"location":"#Supergrassi.select_year-Tuple{DataFrames.DataFrame, Int64}","page":"Introduction","title":"Supergrassi.select_year","text":"function select_year(data::DataFrame, year::Int64)\n\nSelect rows from a DataFrame based on a specific year.\n\nArguments\n\ndata::DataFrame: The DataFrame containing the data.\nyear::Int64: The year to filter the DataFrame by.\n\nReturns\n\nDataFrame: A new DataFrame containing only the rows for the specified year, with columns converted to Float64 if they are strings.\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.sum_kernel-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T<:Real","page":"Introduction","title":"Supergrassi.sum_kernel","text":"sum_kernel(var::Vector{T}, logP::Vector{T}, elasticity::T) where {T <: Real}\n\nArgument:\n\nvar: Vector of variable values.\nlogP: Vector of log prices.\nelasticity: substitution elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.total_capital_parameters-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, T, T, T, T, Supergrassi.Elasticity, T, Bool}} where T","page":"Introduction","title":"Supergrassi.total_capital_parameters","text":"function total_capital_parameters(prices_uk::Vector{T}, prices_eu::Vector{T}, prices_world::Vector{T},\n                              input_uk::Vector{T}, input_eu::Vector{T}, input_world::Vector{T}, input_agg::Vector{T},\n                              surplus::T, capital::T, output::T, labor::T, log_wages::T, elasticity::Elasticity, tau::T, log_scale::Bool) where T\n\nCompute the total parameter (γK) for the firms capital utility function.\n\nMatlab code reference ComputeTheta.m line 254\n\nArguments\n\nprices_uk::Vector{Real} : uk price index\nprices_eu::Vector{Real} : eu price index\nprices_world::Vector{Real} : rest of world price index\ninput_uk::Vector{Real} : uk firms intermediate input\ninput_eu::Vector{Real} : eu firms intermediate input\ninput_world::Vector{Real} : rest of world firms intermediate input\ninput_agg::Vector{Real} : aggreagete firms intermediate input\nsuprlus::Real : firms suprlus, data.kValue\ncapital::Real : firms capital, data.k0\noutput::Real : total household use, data.yValue\nlabor::Real : payments for labor, data.hValue\nlog_wages::Real : aggregate wages of households\nelasticity::Real : substitution elasticity\ntau::Real : ratio of taxes to household use\nlog_scale::Bool : return parameters in log scale\n\nSee also\n\ncompute_wage_index\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.total_input_parameters-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, T, T, T, T, Supergrassi.Elasticity, T, Bool}} where T<:Real","page":"Introduction","title":"Supergrassi.total_input_parameters","text":"function total_input_parameters(prices_uk::Vector{T}, prices_eu::Vector{T}, prices_world::Vector{T},\n                            input_uk::Vector{T}, input_eu::Vector{T}, input_world::Vector{T}, input_agg::Vector{T},\n                            surplus::T, capital::T, output::T, labor::T, log_wages::T, elasticity::Elasticity, tau::T, log_scale::Bool) where {T <: Real}\n\nCompute the total parameter (γM) for the firms input utility function.\n\nMatlab code reference ComputeTheta.m line 251\n\nArguments\n\nprices_uk::Vector{Real} : uk price index\nprices_eu::Vector{Real} : eu price index\nprices_world::Vector{Real} : rest of world price index\ninput_uk::Vector{Real} : uk firms intermediate input\ninput_eu::Vector{Real} : eu firms intermediate input\ninput_world::Vector{Real} : rest of world firms intermediate input\ninput_agg::Vector{Real} : aggreagete firms intermediate input\nsuprlus::Real : firms suprlus, data.kValue\ncapital::Real : firms capital, data.k0\noutput::Real : total household use, data.yValue\nlabor::Real : payments for labor, data.hValue\nlog_wages::Real : aggregate wages of households\nelasticity::Real : substitution elasticity\ntau::Real : ratio of taxes to household use\nlog_scale::Bool : return parameters in log scale\n\nSee also\n\ncompute_wage_index\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.total_labor_parameters-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, T, T, T, T, Supergrassi.Elasticity, T, Bool}} where T","page":"Introduction","title":"Supergrassi.total_labor_parameters","text":"function total_labor_parameters(prices_uk::Vector{T}, prices_eu::Vector{T}, prices_world::Vector{T},\n                            input_uk::Vector{T}, input_eu::Vector{T}, input_world::Vector{T}, input_agg::Vector{T},\n                            surplus::T, capital::T, output::T, labor::T, log_wages::T, elasticity::Elasticity, tau::T, log_scale::Bool) where T\n\nCompute the total parameter (γH) for the firms labor utility function.\n\nMatlab code reference ComputeTheta.m line 249\n\nArguments\n\nprices_uk::Vector{Real} : uk price index\nprices_eu::Vector{Real} : eu price index\nprices_world::Vector{Real} : rest of world price index\ninput_uk::Vector{Real} : uk firms intermediate input\ninput_eu::Vector{Real} : eu firms intermediate input\ninput_world::Vector{Real} : rest of world firms intermediate input\ninput_agg::Vector{Real} : aggreagete firms intermediate input\nsuprlus::Real : firms suprlus, data.kValue\ncapital::Real : firms capital, data.k0\noutput::Real : total household use, data.yValue\nlabor::Real : payments for labor, data.hValue\nlog_wages::Real : aggregate wages of households\nelasticity::Real : substitution elasticity\ntau::Real : ratio of taxes to household use\nlog_scale::Bool : return parameters in log scale\n\nSee also\n\ncompute_wage_index\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.total_parameters-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T<:Real","page":"Introduction","title":"Supergrassi.total_parameters","text":"function total_parameters(log_price_index::Vector{T}, quantity::Vector{T}, elasticity::T ) where {T <: Real}\n\nCompute the aggregate utility function parameter. Parameters of this type appear in multiple utility function in the paper, and are annotated (at least) α, β1, β2, γ and ρ.\n\nThis is refactored from the Matlab code in e.g. ComputeTheta.m line 59\n\nArguments\n\nlog_price_index::Vector{Real} : price index computed by log_price_index\nquantity:Vector{Real} : aggregate quantity [f, x1, x2, I, m]\nelasticity::Real : substitution elasticity. One of [ϵ, χ1, χ2, η, ξ]\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.unpack_x-Tuple{Int64, Vector{<:Real}}","page":"Introduction","title":"Supergrassi.unpack_x","text":"function unpack_x(n::Int, x::Vector{<:Number})\n\nUnpack the vector of equilibrium variables (Puk, zUC, E, muI, Delta) x into five separate variables.\n\nArguments\n\nn::Int: Length of vector variables\nx::Vector{Real}: Vector of equilibrium variables. Should be of size 3n+2\n\nOutputs\n\nlog_price_uk::Vector[n] : Domestic price\nzOC::Vector[n] : Operating cost\nexpenditure::Real : expenditure\nlog_muI::Real : Investment TFP\nlog_Delta::Vector[n] : Depreciation parameter\n\n\n\n\n\n","category":"method"},{"location":"#Supergrassi.weight_kernel-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Introduction","title":"Supergrassi.weight_kernel","text":"weight_kernel(a::T, b::T, elasticity::T) where {T <: Real}\n\nComputes a/b^(1-elasticity)\n\nArgument:\n\na: Numerator value.\nb: Denominator value.\nelasticity: substitution elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"#Constants","page":"Introduction","title":"Constants","text":"","category":"section"}]
}
